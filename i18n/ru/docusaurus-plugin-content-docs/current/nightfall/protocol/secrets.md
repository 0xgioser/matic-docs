---
id: secrets
title: Внутреннее распространение секретов
sidebar_label: In Band Secret Distribution
description: "Решение для шифрования секретов и обеспечения их расшифровки."
keywords:
  - docs
  - polygon
  - nightfall
  - secret
  - encryption
  - key
image: https://matic.network/banners/matic-network-16x9.png
---
import katex from 'katex';

## Обзор {#overview}

Чтобы обеспечить получение получателем секретной информации, необходимой для расходования обязательств, отправитель
шифрует секреты (*salt*, *value*, *tokenId*, *ercAddress*) обязательства, отправленного получателю, и
доказывает с помощью ZKP, что эти данные зашифрованы правильно, с помощью публичного ключа получателя. Используется парадигма гибридного шифрования [**KEM-DEM**](https://eprint.iacr.org/2006/265.pdf).

## Гибридное шифрование KEM-DEM {#kem-dem-hybrid-encryption}


### Создание ключа {#key-creation}

Используйте эллиптическую кривую (здесь мы используем кривую Baby Jubjub) `E` на конечном поле `Fp`, где `p` — это большой
порядок, а `G` — это генератор.

Элис генерирует случайную эфемерную асимметричную пару ключей   :
$x_e \; \leftarrow\; \{0, 1\}^{256} \qquad Q_e \coloneqq x_eG$

Эти ключи используются только один раз и являются уникальными для данной транзакции, обеспечивая нам идеальную прямую секретность.

### Шифрование {#encryption}

Процесс шифрования включает два шага: шаг KEM для извлечения симметричного ключа шифрования из общего секрета и шаг DEM для шифрования открытого текста с помощью ключа шифрования.

### Метод инкапсуляции ключа (шифрование) {#key-encapsulation-method-encryption}
Используя ранее сгенерированный ассиметричный приватный ключ, мы получаем общий секрет, $key_{DH}$, с помощью стандартного алгоритма Диффи-Хеллмана. Он хэшируется наряду с эфемерным публичным ключом для получения ключа шифрования.

$key_{DH} \coloneqq x_eQ_r \qquad key_{enc} \coloneqq H_{K}(key_{DH} \; + \;Q_e)$


где  
   — публичный ключ получателя  

$Domain_{K} \coloneqq \text{to\_field}(\text{SHA256}(\text{'nightfall-kem'}))$


### Метод инкапсуляции данных (шифрование) {#data-encapsulation-method-encryption}
Эффективная работы схемы обеспечивается использованием для шифрования блочного шифра в режиме гаммирования, где алгоритмом шифрования является хэш mimc. Учитывая, что эфемерные ключи являются уникальными для каждой транзакции, нет необходимости включать nonce. Шифрование $i^{th}$-сообщения выглядит следующим образом:

$c_i \coloneqq H_{D}(key_{enc} + i) + p_i$

где  

$Domain_{D} \coloneqq \text{to\_field}(\text{SHA256}(\text{'nightfall-dem'}))$

Затем отправитель предоставляет получателю $(Q_e, \text{ciphertexts})$. Они включены в состав структуры транзакции, отправленной в цепочку.

### Дешифрование {#decryption}
Чтобы произвести дешифрование, получатель выполняет слегка модифицированную версию шагов KEM-DEM.

### Метод инкапсуляции ключа (дешифрование) {#key-encapsulation-method-decryption}
При заданном $Q_e$ получатель может вычислить ключ шифрования локально, выполнив следующие шаги.

$$key_{DH} \coloneqq x_eQ_e \qquad key_{enc} \coloneqq H_{K}(key_{DH} \; + \;Q_e)$$

где  
   — эфемерный публичный ключ  

$Domain_{K} \coloneqq \text{to\_field}(\text{SHA256}(\text{'nightfall-kem'}))$

### Метод инкапсуляции данных (дешифрование) {#data-encapsulation-method-decryption}
С $key_{enc}$ and an array of ciphertexts, the $i_{th}$ открытый текст может быть восстановлен следующим образом:

$$p_i \coloneqq c_i - H_{D}(key_{enc} + i)$$

где  

$Domain_{D} \coloneqq \text{to\_field}(SHA256(\text{'nightfall-dem'}))$


## Извлечение и генерация различных ключей, задействованных в шифровании, владении обязательствами и расходовании {#derivation-and-generation-of-the-various-keys-involved-in-encryption-ownership-of-commitments-and-spending}

С помощью BIP39 генерируйте `mnemonic` из 12 слов, а из нее генерируйте `seed` путем вызова `mnemonicToSeedSync`.
Затем, следуя стандартам BIP32 и BIP44, генерируйте `rootKey` на основе этой `seed` и `path`.

```
zkpPrivateKey = mimc(rootKey, 2708019456231621178814538244712057499818649907582893776052749473028258908910)
where 2708019456231621178814538244712057499818649907582893776052749473028258908910 is keccak256(`zkpPrivateKey`) % BN128_GROUP_ORDER

nullifierKey = mimc(rootKey, 7805187439118198468809896822299973897593108379494079213870562208229492109015n)
where 7805187439118198468809896822299973897593108379494079213870562208229492109015n is keccak256(`nullifierKey`) % BN128_GROUP_ORDER

zkpPublicKey = zkpPrivateKey * G
```

Если будут скомпрометированы `rootKey` или `mnemonic`, злоумышленник сможет вычислить `zkpPrivateKey` и `nullifierKey`.
`zkpPrivateKey` может быть использован для дешифрования секретов обязательства, в то время как `nullifierKey` может быть использован для расходования обязательства.
Поэтому `rootKey` и `mnemonic` должны храниться очень безопасным способом.

Приложения, которые будут использовать `ZkpKeys` для генерации этих ключей, могут хранить `rootKey` в различных устройствах, разделив
его на доли с помощью совместного использования секретов по схеме Шамира.

Кроме того, рекомендуется хранить `zkpPrivateKey` и `nullifierKey` по отдельности, чтобы предотвратить кражу обязательств в том случае, если один из них будет
скомпрометирован.

Ниже показаны шаги по извлечению различных ключей в Nightfall
![](../imgs/key-derivation.png)
